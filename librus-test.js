#!/usr/bin/env node
/**
 * librus-test - Test the Librus notification pipeline
 *
 * Fetches a random item from Librus API, analyzes it with OpenAI,
 * and sends a test email.
 *
 * Usage:
 *   librus-test <email>
 *   librus-test me@flakm.com
 *   librus-test --type=message me@flakm.com
 *   librus-test --type=grade me@flakm.com
 *
 * Options:
 *   --type=TYPE    Item type to fetch: message, announcement, grade, event (default: random)
 *   --dry-run      Don't send email, just print the result
 *   --help         Show this help
 *
 * Environment variables (from .env or environment):
 *   LIBRUS_USERNAME, LIBRUS_PASSWORD - Librus credentials
 *   OPENAI_API_KEY                   - OpenAI API key
 *   EMAIL_HOST, EMAIL_PORT, EMAIL_USER, EMAIL_PASSWORD, EMAIL_FROM - SMTP config
 */

import Librus from 'librus-api';
import dotenv from 'dotenv';
import nodemailer from 'nodemailer';
import { summarizeAndClassify } from './src/openai-service.js';
import { logger } from './src/logger.js';

dotenv.config();

function printUsage() {
  console.log(`
librus-test - Test the Librus notification pipeline

Usage:
  librus-test <email>
  librus-test --type=message me@flakm.com
  librus-test --dry-run me@flakm.com

Options:
  --type=TYPE    Item type: message, announcement, grade, event (default: random)
  --dry-run      Don't send email, just print the result
  --help         Show this help

Examples:
  librus-test me@flakm.com                    # Send test with random item
  librus-test --type=grade me@flakm.com       # Send test with a grade
  librus-test --dry-run me@flakm.com          # Analyze but don't send email
`);
}

function parseArgs(args) {
  const result = { email: null, type: null, dryRun: false, help: false };

  for (const arg of args) {
    if (arg === '--help' || arg === '-h') {
      result.help = true;
    } else if (arg === '--dry-run') {
      result.dryRun = true;
    } else if (arg.startsWith('--type=')) {
      result.type = arg.split('=')[1];
    } else if (!arg.startsWith('-')) {
      result.email = arg;
    }
  }

  return result;
}

function generateTestEmailHtml(analysis, item, type) {
  const urgencyColors = {
    'PILNE': '#dc3545',
    'NORMALNE': '#ffc107',
    'NIEPILNE': '#28a745'
  };

  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; }
    h1 { color: #2c3e50; border-bottom: 3px solid #e74c3c; padding-bottom: 10px; }
    .test-badge { background-color: #e74c3c; color: white; padding: 4px 12px; border-radius: 4px; font-size: 14px; font-weight: bold; }
    .urgency-badge { background-color: ${urgencyColors[analysis.urgency] || urgencyColors.NORMALNE}; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
    .summary { background-color: #f8f9fa; padding: 15px; border-left: 4px solid #3498db; margin: 20px 0; }
    .key-points { background-color: #fff; padding: 15px; border: 1px solid #dee2e6; border-radius: 5px; }
    .raw-item { margin-top: 30px; padding: 15px; background: #f5f5f5; border-radius: 5px; border: 1px dashed #ccc; }
    .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #dee2e6; color: #6c757d; font-size: 12px; }
    pre { background: #2d2d2d; color: #f8f8f2; padding: 15px; border-radius: 5px; overflow-x: auto; font-size: 12px; }
  </style>
</head>
<body>
  <h1>ðŸ§ª <span class="test-badge">TEST</span> Librus Notification</h1>

  <p>This is a <strong>test email</strong> from librus-test.</p>

  <h2>Analysis Result <span class="urgency-badge">${analysis.urgency}</span></h2>

  <div class="summary">
    <strong>Summary:</strong><br>
    ${analysis.summary}
  </div>

  <div class="key-points">
    <strong>Key Points:</strong>
    <ul>
      ${analysis.keyPoints.map(point => `<li>${point}</li>`).join('')}
    </ul>
  </div>

  <div class="raw-item">
    <h3>ðŸ“¦ Raw ${type} Data:</h3>
    <pre>${JSON.stringify(item, null, 2)}</pre>
  </div>

  <div class="footer">
    <p>ðŸ§ª This is a test email generated by librus-test</p>
    <p>Generated at: ${new Date().toISOString()}</p>
  </div>
</body>
</html>
`;
}

async function fetchItem(client, type) {
  const types = ['message', 'announcement', 'grade', 'event'];
  const selectedType = type || types[Math.floor(Math.random() * types.length)];

  console.log(`Fetching ${selectedType}...`);

  switch (selectedType) {
    case 'message': {
      const messages = await client.inbox.listInbox(6);
      if (messages && messages.length > 0) {
        const msg = messages[Math.floor(Math.random() * messages.length)];
        const fullMsg = await client.inbox.getMessage(6, msg.id);
        return {
          type: 'messages',
          item: {
            id: msg.id,
            title: msg.title,
            body: fullMsg.content || '',
            date: msg.date,
            user: fullMsg.user || msg.user
          }
        };
      }
      throw new Error('No messages found');
    }
    case 'announcement': {
      const announcements = await client.inbox.listAnnouncements();
      if (announcements && announcements.length > 0) {
        const ann = announcements[Math.floor(Math.random() * announcements.length)];
        return {
          type: 'announcements',
          item: {
            id: `${ann.title}_${ann.date}`,
            title: ann.title,
            content: ann.content || '',
            date: ann.date,
            user: ann.user || ann.author
          }
        };
      }
      throw new Error('No announcements found');
    }
    case 'grade': {
      const allGrades = await client.info.getGrades();
      const grades = [];
      for (const subject of allGrades || []) {
        for (const semester of subject.semester || []) {
          for (const grade of semester.grades || []) {
            grades.push({
              id: grade.id,
              subject: subject.name,
              value: grade.value,
              info: grade.info
            });
          }
        }
      }
      if (grades.length > 0) {
        return {
          type: 'grades',
          item: grades[Math.floor(Math.random() * grades.length)]
        };
      }
      throw new Error('No grades found');
    }
    case 'event': {
      const month = new Date().getMonth() + 1;
      const year = new Date().getFullYear();
      const calendar = await client.calendar.getCalendar(month, year);
      const events = [];
      for (const dayEvents of calendar || []) {
        for (const event of dayEvents || []) {
          if (event && event.id !== -1) {
            events.push({
              id: event.id,
              title: event.title,
              day: event.day,
              description: ''
            });
          }
        }
      }
      if (events.length > 0) {
        return {
          type: 'events',
          item: events[Math.floor(Math.random() * events.length)]
        };
      }
      throw new Error('No events found');
    }
    default:
      throw new Error(`Unknown type: ${selectedType}`);
  }
}

async function main() {
  const args = parseArgs(process.argv.slice(2));

  if (args.help) {
    printUsage();
    process.exit(0);
  }

  if (!args.email) {
    console.error('Error: email address required\n');
    printUsage();
    process.exit(1);
  }

  const requiredEnvVars = ['LIBRUS_USERNAME', 'LIBRUS_PASSWORD', 'OPENAI_API_KEY'];
  for (const envVar of requiredEnvVars) {
    if (!process.env[envVar]) {
      console.error(`Error: Missing required environment variable: ${envVar}`);
      process.exit(1);
    }
  }

  if (!args.dryRun) {
    const emailEnvVars = ['EMAIL_HOST', 'EMAIL_PORT', 'EMAIL_USER', 'EMAIL_PASSWORD'];
    for (const envVar of emailEnvVars) {
      if (!process.env[envVar]) {
        console.error(`Error: Missing required environment variable: ${envVar}`);
        process.exit(1);
      }
    }
  }

  try {
    console.log('Authenticating with Librus...');
    const client = new Librus();
    await client.authorize(process.env.LIBRUS_USERNAME, process.env.LIBRUS_PASSWORD);
    console.log('âœ“ Authenticated');

    const { type, item } = await fetchItem(client, args.type);
    console.log(`âœ“ Fetched ${type}: ${item.title || item.subject || item.id}`);

    console.log('Analyzing with OpenAI...');
    const analysis = await summarizeAndClassify([item], type);
    console.log(`âœ“ Analysis complete - Urgency: ${analysis.urgency}`);

    console.log('\n--- Analysis Result ---');
    console.log(`Type: ${type}`);
    console.log(`Urgency: ${analysis.urgency}`);
    console.log(`Summary: ${analysis.summary}`);
    console.log('Key Points:');
    analysis.keyPoints.forEach(p => console.log(`  â€¢ ${p}`));
    console.log('');

    if (args.dryRun) {
      console.log('Dry run - not sending email');
      console.log('\n--- Raw Item ---');
      console.log(JSON.stringify(item, null, 2));
    } else {
      console.log(`Sending test email to ${args.email}...`);

      const transporter = nodemailer.createTransport({
        host: process.env.EMAIL_HOST,
        port: parseInt(process.env.EMAIL_PORT),
        secure: false,
        auth: {
          user: process.env.EMAIL_USER,
          pass: process.env.EMAIL_PASSWORD
        }
      });

      const html = generateTestEmailHtml(analysis, item, type);
      const subject = `[TEST] Librus: ${type} - ${analysis.urgency}`;

      await transporter.sendMail({
        from: process.env.EMAIL_FROM || process.env.EMAIL_USER,
        to: args.email,
        subject,
        html
      });

      console.log(`âœ“ Email sent to ${args.email}`);
    }

    console.log('\nDone!');
  } catch (err) {
    console.error(`Error: ${err.message}`);
    process.exit(1);
  }
}

main();
